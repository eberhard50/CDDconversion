#!/usr/bin/env python3
"""
Comprehensive ODX-D Generator
Creates complete ODX-D files using ALL information extracted from CDD files
"""

import xml.dom.minidom
from enhanced_cdd_parser import EnhancedCDDParser, CDDDocument, CDDProtocolService, CDDDID
from datetime import datetime
from typing import List, Dict


class ComprehensiveODXGenerator:
    """Generates complete ODX-D files with all CDD information"""
    
    def __init__(self):
        self.ecu_name = ""
        self.timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    def generate_complete_odx(self, cdd_file_path: str, ecu_name: str = None) -> str:
        """Generate complete ODX-D XML from CDD file"""
        
        # Parse CDD file
        parser = EnhancedCDDParser()
        document = parser.parse_file(cdd_file_path)
        
        # Set ECU name
        self.ecu_name = ecu_name or document.ecu_name or "ECU"
        document.ecu_name = self.ecu_name
        
        print(f"ðŸ”„ Generating comprehensive ODX-D for {self.ecu_name}")
        print(f"   ðŸ“‹ Services to convert: {len(document.protocol_services)}")
        print(f"   ðŸ”¢ DIDs to convert: {len(document.dids)}")
        
        # Generate ODX XML
        odx_xml = self._create_complete_odx_xml(document)
        
        print(f"âœ… ODX-D generation complete!")
        return odx_xml
    
    def _create_complete_odx_xml(self, document: CDDDocument) -> str:
        """Create complete ODX-D XML structure"""
        
        # Start building ODX XML
        odx_lines = [
            '<?xml version="1.0" encoding="UTF-8"?>',
            '<ODX xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" MODEL-VERSION="2.2.0" xsi:noNamespaceSchemaLocation="odx.xsd">',
            f'  <!--Generated by Comprehensive CDD-to-ODX Converter on {self.timestamp}-->',
            f'  <!--Source: {document.manufacturer} CDD file with {len(document.protocol_services)} services and {len(document.dids)} DIDs-->',
            f'  <DIAG-LAYER-CONTAINER ID="DLC.{self.ecu_name}">',
            f'    <SHORT-NAME>{self.ecu_name}</SHORT-NAME>',
            f'    <LONG-NAME>{self.ecu_name} Diagnostic Layer Container</LONG-NAME>',
            f'    <ECU-VARIANT ID="EV.{self.ecu_name}">',
            f'      <SHORT-NAME>{self.ecu_name}</SHORT-NAME>',
            f'      <LONG-NAME>{self.ecu_name} ECU Variant</LONG-NAME>',
            '      <PROT-STACK-SNREF SHORT-NAME="ISO_15765_3_on_ISO_15765_2_on_ISO_11898_2_DWCAN" DOCTYPE="PROTOCOL-STACK" DOCREF="ISO_15765_3_on_ISO_15765_2"/>',
        ]
        
        # Add Data Dictionary Specification
        odx_lines.extend(self._generate_data_dictionary(document.dids))
        
        # Add Diagnostic Communications
        odx_lines.extend(self._generate_diag_communications(document.protocol_services, document.dids))
        
        # Close XML structure
        odx_lines.extend([
            '    </ECU-VARIANT>',
            '  </DIAG-LAYER-CONTAINER>',
            '</ODX>'
        ])
        
        # Join and pretty print
        xml_content = '\n'.join(odx_lines)
        
        try:
            # Pretty print the XML
            dom = xml.dom.minidom.parseString(xml_content)
            return dom.toprettyxml(indent="  ", encoding="UTF-8").decode("UTF-8")
        except:
            # Fallback if pretty printing fails
            return xml_content
    
    def _generate_data_dictionary(self, dids: List[CDDDID]) -> List[str]:
        """Generate DIAG-DATA-DICTIONARY-SPEC section"""
        lines = [
            '      <DIAG-DATA-DICTIONARY-SPEC>',
            '        <DATA-OBJECT-PROPS>'
        ]
        
        # Generate data object properties for each DID
        for did in dids:
            lines.extend(self._generate_did_data_object(did))
        
        lines.extend([
            '        </DATA-OBJECT-PROPS>',
            '      </DIAG-DATA-DICTIONARY-SPEC>'
        ])
        
        return lines
    
    def _generate_did_data_object(self, did: CDDDID) -> List[str]:
        """Generate data object property for a single DID"""
        
        # Clean name for ID
        clean_name = did.qualifier.replace(' ', '_').replace('-', '_')
        
        lines = [
            f'          <DATA-OBJECT-PROP ID="DOP.{clean_name}">',
            f'            <SHORT-NAME>{did.qualifier}</SHORT-NAME>',
            f'            <LONG-NAME>{did.name}</LONG-NAME>'
        ]
        
        # Add description if available
        if did.description:
            lines.append(f'            <DESC><p>{self._escape_xml(did.description[:200])}...</p></DESC>')
        
        # Add computation method
        lines.extend([
            '            <COMPU-METHOD>',
            '              <CATEGORY>IDENTICAL</CATEGORY>',
            '            </COMPU-METHOD>'
        ])
        
        # Determine data type based on DID number range or description
        bit_length = self._estimate_bit_length(did)
        
        lines.extend([
            f'            <DIAG-CODED-TYPE BASE-DATA-TYPE="A_BYTEFIELD" xsi:type="STANDARD-LENGTH-TYPE">',
            f'              <BIT-LENGTH>{bit_length}</BIT-LENGTH>',
            '            </DIAG-CODED-TYPE>',
            '            <PHYSICAL-TYPE BASE-DATA-TYPE="A_BYTEFIELD"/>',
            '          </DATA-OBJECT-PROP>'
        ])
        
        return lines
    
    def _estimate_bit_length(self, did: CDDDID) -> int:
        """Estimate bit length based on DID information"""
        # Common DID ranges and their typical sizes
        did_num = did.number
        
        if did_num == 0xF190:  # VIN
            return 136  # 17 bytes
        elif did_num in range(0xF180, 0xF19F):  # Vehicle identification
            return 64   # 8 bytes
        elif did_num in range(0xF1A0, 0xF1FF):  # ECU identification
            return 128  # 16 bytes
        elif did_num in range(0xF0, 0xFF):      # Manufacturer specific
            return 32   # 4 bytes
        else:
            return 64   # Default 8 bytes
    
    def _generate_diag_communications(self, services: List[CDDProtocolService], dids: List[CDDDID]) -> List[str]:
        """Generate DIAG-COMMS section with all services"""
        
        lines = [
            '      <DIAG-COMMS>',
            f'        <DIAG-COMM ID="DC.{self.ecu_name}">',
            f'          <SHORT-NAME>{self.ecu_name}_DiagComm</SHORT-NAME>',
            f'          <LONG-NAME>{self.ecu_name} Diagnostic Communication</LONG-NAME>',
            '          <SERVICES>'
        ]
        
        # Generate each service
        for service in services:
            lines.extend(self._generate_service(service, dids))
        
        lines.extend([
            '          </SERVICES>',
            '        </DIAG-COMM>',
            '      </DIAG-COMMS>'
        ])
        
        return lines
    
    def _generate_service(self, service: CDDProtocolService, dids: List[CDDDID]) -> List[str]:
        """Generate a complete UDS service"""
        
        # Clean service name for ID
        clean_name = service.qualifier.replace(' ', '_').replace('-', '_')
        
        lines = [
            f'            <SINGLE-ECU-JOB ID="SJ.{clean_name}">',
            f'              <SHORT-NAME>{service.qualifier}</SHORT-NAME>',
            f'              <LONG-NAME>{service.name}</LONG-NAME>'
        ]
        
        # Add functional/physical addressing info
        if service.func:
            lines.append('              <FUNCTIONAL-UNIT-REF ID-REF="FU.Functional"/>')
        if service.phys:
            lines.append('              <FUNCTIONAL-UNIT-REF ID-REF="FU.Physical"/>')
        
        # Generate request
        if service.request:
            lines.extend(self._generate_request(service.request, service.qualifier))
        
        # Generate positive response
        if service.positive_response:
            lines.extend(self._generate_positive_response(service.positive_response, service.qualifier, dids))
        
        # Generate negative response
        if service.negative_response:
            lines.extend(self._generate_negative_response(service.negative_response, service.qualifier))
        
        lines.append('            </SINGLE-ECU-JOB>')
        
        return lines
    
    def _generate_request(self, request, service_qualifier: str) -> List[str]:
        """Generate service request"""
        
        lines = [
            f'              <REQUEST ID="RQ.{service_qualifier}">',
            f'                <SHORT-NAME>{request.qualifier}</SHORT-NAME>',
            f'                <LONG-NAME>{request.name}</LONG-NAME>',
            '                <PARAMS>'
        ]
        
        # Add request parameters from components
        for comp in request.components:
            if comp.component_type == 'CONSTCOMP' and comp.spec == 'sid':
                # Service ID component
                lines.extend([
                    f'                  <VALUE ID="V.{comp.qualifier}">',
                    f'                    <SHORT-NAME>{comp.qualifier}</SHORT-NAME>',
                    f'                    <LONG-NAME>{comp.name}</LONG-NAME>',
                    f'                    <CODED-VALUE>{comp.value}</CODED-VALUE>',
                    '                  </VALUE>'
                ])
            elif comp.component_type in ['STATICCOMP', 'SIMPLEPROXYCOMP']:
                # Other parameters
                lines.extend([
                    f'                  <PARAM ID="P.{comp.qualifier}">',
                    f'                    <SHORT-NAME>{comp.qualifier}</SHORT-NAME>',
                    f'                    <LONG-NAME>{comp.name}</LONG-NAME>',
                    '                  </PARAM>'
                ])
        
        lines.extend([
            '                </PARAMS>',
            '              </REQUEST>'
        ])
        
        return lines
    
    def _generate_positive_response(self, response, service_qualifier: str, dids: List[CDDDID]) -> List[str]:
        """Generate positive response"""
        
        lines = [
            f'              <POS-RESPONSE ID="PR.{service_qualifier}">',
            f'                <SHORT-NAME>{response.qualifier}</SHORT-NAME>',
            f'                <LONG-NAME>{response.name}</LONG-NAME>',
            '                <PARAMS>'
        ]
        
        # Add response parameters
        for comp in response.components:
            if comp.component_type == 'CONSTCOMP' and comp.spec == 'sid':
                # Positive response SID
                lines.extend([
                    f'                  <VALUE ID="V.{comp.qualifier}">',
                    f'                    <SHORT-NAME>{comp.qualifier}</SHORT-NAME>',
                    f'                    <LONG-NAME>{comp.name}</LONG-NAME>',
                    f'                    <CODED-VALUE>{comp.value}</CODED-VALUE>',
                    '                  </VALUE>'
                ])
            elif comp.component_type in ['STATICCOMP', 'SIMPLEPROXYCOMP']:
                # Data parameters
                if 'DID' in service_qualifier and 'Read' in service_qualifier:
                    # For ReadDataByIdentifier, link to DID data
                    matching_did = self._find_matching_did(comp, dids)
                    if matching_did:
                        lines.extend([
                            f'                  <PARAM ID="P.{comp.qualifier}">',
                            f'                    <SHORT-NAME>{comp.qualifier}</SHORT-NAME>',
                            f'                    <LONG-NAME>{comp.name}</LONG-NAME>',
                            f'                    <DOP-REF ID-REF="DOP.{matching_did.qualifier}"/>',
                            '                  </PARAM>'
                        ])
                    else:
                        lines.extend([
                            f'                  <PARAM ID="P.{comp.qualifier}">',
                            f'                    <SHORT-NAME>{comp.qualifier}</SHORT-NAME>',
                            f'                    <LONG-NAME>{comp.name}</LONG-NAME>',
                            '                  </PARAM>'
                        ])
                else:
                    lines.extend([
                        f'                  <PARAM ID="P.{comp.qualifier}">',
                        f'                    <SHORT-NAME>{comp.qualifier}</SHORT-NAME>',
                        f'                    <LONG-NAME>{comp.name}</LONG-NAME>',
                        '                  </PARAM>'
                    ])
        
        lines.extend([
            '                </PARAMS>',
            '              </POS-RESPONSE>'
        ])
        
        return lines
    
    def _generate_negative_response(self, response, service_qualifier: str) -> List[str]:
        """Generate negative response"""
        
        lines = [
            f'              <NEG-RESPONSE ID="NR.{service_qualifier}">',
            f'                <SHORT-NAME>{response.qualifier}</SHORT-NAME>',
            f'                <LONG-NAME>{response.name}</LONG-NAME>',
            '                <PARAMS>'
        ]
        
        # Add standard negative response parameters
        for comp in response.components:
            if comp.component_type == 'CONSTCOMP':
                lines.extend([
                    f'                  <VALUE ID="V.{comp.qualifier}">',
                    f'                    <SHORT-NAME>{comp.qualifier}</SHORT-NAME>',
                    f'                    <LONG-NAME>{comp.name}</LONG-NAME>',
                    f'                    <CODED-VALUE>{comp.value}</CODED-VALUE>',
                    '                  </VALUE>'
                ])
            else:
                lines.extend([
                    f'                  <PARAM ID="P.{comp.qualifier}">',
                    f'                    <SHORT-NAME>{comp.qualifier}</SHORT-NAME>',
                    f'                    <LONG-NAME>{comp.name}</LONG-NAME>',
                    '                  </PARAM>'
                ])
        
        lines.extend([
            '                </PARAMS>',
            '              </NEG-RESPONSE>'
        ])
        
        return lines
    
    def _find_matching_did(self, component, dids: List[CDDDID]):
        """Find DID that matches a component"""
        # This is a simplified matching - could be enhanced
        for did in dids[:10]:  # Check first 10 DIDs for performance
            if 'VIN' in component.name.upper() and did.number == 0xF190:
                return did
            elif component.qualifier in did.qualifier:
                return did
        return None
    
    def _escape_xml(self, text: str) -> str:
        """Escape XML special characters"""
        if not text:
            return ""
        return (text.replace('&', '&amp;')
                   .replace('<', '&lt;')
                   .replace('>', '&gt;')
                   .replace('"', '&quot;')
                   .replace("'", '&apos;'))


def test_comprehensive_generator():
    """Test the comprehensive ODX generator"""
    
    generator = ComprehensiveODXGenerator()
    
    # Generate complete ODX from CDD
    odx_content = generator.generate_complete_odx(
        "NX3_UDS_CanIfCfg.cdd", 
        "NX3_UDS_CanIfCfg"
    )
    
    # Save to file
    output_file = "NX3_UDS_CanIfCfg_COMPLETE.odx-d"
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(odx_content)
    
    print(f"\nðŸŽ‰ Complete ODX-D file generated: {output_file}")
    print(f"ðŸ“Š File size: {len(odx_content)} characters")
    
    # Show preview
    lines = odx_content.split('\n')
    print(f"\nðŸ“‹ Preview (first 30 lines):")
    for i, line in enumerate(lines[:30]):
        print(f"{i+1:2}: {line}")
    
    print(f"\n... ({len(lines)} total lines)")
    
    return odx_content


if __name__ == "__main__":
    test_comprehensive_generator()